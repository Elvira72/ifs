import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toESM
} from "./chunk-CWGEVKOD.js";

// ../node_modules/ms/index.js
var require_ms = __commonJS({
  "../node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h2 = m * 60;
    var d = h2 * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled2;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled2(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// ../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../node_modules/kolorist/dist/module/index.js
var module_exports = {};
__export(module_exports, {
  ansi256: () => ansi256,
  ansi256Bg: () => ansi256Bg,
  bgBlack: () => bgBlack,
  bgBlue: () => bgBlue,
  bgCyan: () => bgCyan,
  bgGray: () => bgGray,
  bgGreen: () => bgGreen,
  bgLightBlue: () => bgLightBlue,
  bgLightCyan: () => bgLightCyan,
  bgLightGray: () => bgLightGray,
  bgLightGreen: () => bgLightGreen,
  bgLightMagenta: () => bgLightMagenta,
  bgLightRed: () => bgLightRed,
  bgLightYellow: () => bgLightYellow,
  bgMagenta: () => bgMagenta,
  bgRed: () => bgRed,
  bgWhite: () => bgWhite,
  bgYellow: () => bgYellow,
  black: () => black,
  blue: () => blue,
  bold: () => bold,
  cyan: () => cyan,
  dim: () => dim,
  gray: () => gray,
  green: () => green,
  hidden: () => hidden,
  inverse: () => inverse,
  italic: () => italic,
  lightBlue: () => lightBlue,
  lightCyan: () => lightCyan,
  lightGray: () => lightGray,
  lightGreen: () => lightGreen,
  lightMagenta: () => lightMagenta,
  lightRed: () => lightRed,
  lightYellow: () => lightYellow,
  link: () => link,
  magenta: () => magenta,
  options: () => options,
  red: () => red,
  reset: () => reset,
  strikethrough: () => strikethrough,
  stripColors: () => stripColors,
  trueColor: () => trueColor,
  trueColorBg: () => trueColorBg,
  underline: () => underline,
  white: () => white,
  yellow: () => yellow
});
function kolorist(start, end, level) {
  if (level === void 0) {
    level = 1;
  }
  var open = "\x1B[" + start + "m";
  var close = "\x1B[" + end + "m";
  var regex = new RegExp("\\x1b\\[" + end + "m", "g");
  return function(str) {
    return options.enabled && options.supportLevel >= level ? open + ("" + str).replace(regex, open) + close : "" + str;
  };
}
function rgbToAnsi256(r, g, b) {
  if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
    if (r < 8) {
      return 16;
    }
    if (r > 248) {
      return 231;
    }
    return Math.round((r - 8) / 247 * 24) + 232;
  }
  var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
}
function stripColors(str) {
  return ("" + str).replace(/\x1b\[[0-9;]+m/g, "").replace(/\x1b\]8;;.*?\x07(.*?)\x1b\]8;;\x07/g, function(_, group) {
    return group;
  });
}
function link(text, url) {
  return options.enabled ? OSC + "8" + SEP + SEP + url + BEL + text + OSC + "8" + SEP + SEP + BEL : text + " (​" + url + "​)";
}
var enabled, globalVar, supportLevel, _a, FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, COLORTERM, options, reset, bold, dim, italic, underline, inverse, hidden, strikethrough, black, red, green, yellow, blue, magenta, cyan, white, gray, lightGray, lightRed, lightGreen, lightYellow, lightBlue, lightMagenta, lightCyan, bgBlack, bgRed, bgGreen, bgYellow, bgBlue, bgMagenta, bgCyan, bgWhite, bgGray, bgLightRed, bgLightGreen, bgLightYellow, bgLightBlue, bgLightMagenta, bgLightCyan, bgLightGray, ansi256, ansi256Bg, trueColor, trueColorBg, OSC, BEL, SEP;
var init_module = __esm({
  "../node_modules/kolorist/dist/module/index.js"() {
    enabled = true;
    globalVar = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
    supportLevel = 0;
    if (globalVar.process && globalVar.process.env && globalVar.process.stdout) {
      _a = globalVar.process.env, FORCE_COLOR = _a.FORCE_COLOR, NODE_DISABLE_COLORS = _a.NODE_DISABLE_COLORS, NO_COLOR = _a.NO_COLOR, TERM = _a.TERM, COLORTERM = _a.COLORTERM;
      if (NODE_DISABLE_COLORS || NO_COLOR || FORCE_COLOR === "0") {
        enabled = false;
      } else if (FORCE_COLOR === "1" || FORCE_COLOR === "2" || FORCE_COLOR === "3") {
        enabled = true;
      } else if (TERM === "dumb") {
        enabled = false;
      } else if ("CI" in globalVar.process.env && [
        "TRAVIS",
        "CIRCLECI",
        "APPVEYOR",
        "GITLAB_CI",
        "GITHUB_ACTIONS",
        "BUILDKITE",
        "DRONE"
      ].some(function(vendor) {
        return vendor in globalVar.process.env;
      })) {
        enabled = true;
      } else {
        enabled = process.stdout.isTTY;
      }
      if (enabled) {
        if (process.platform === "win32") {
          supportLevel = 3;
        } else {
          if (COLORTERM && (COLORTERM === "truecolor" || COLORTERM === "24bit")) {
            supportLevel = 3;
          } else if (TERM && (TERM.endsWith("-256color") || TERM.endsWith("256"))) {
            supportLevel = 2;
          } else {
            supportLevel = 1;
          }
        }
      }
    }
    options = {
      enabled,
      supportLevel
    };
    reset = kolorist(0, 0);
    bold = kolorist(1, 22);
    dim = kolorist(2, 22);
    italic = kolorist(3, 23);
    underline = kolorist(4, 24);
    inverse = kolorist(7, 27);
    hidden = kolorist(8, 28);
    strikethrough = kolorist(9, 29);
    black = kolorist(30, 39);
    red = kolorist(31, 39);
    green = kolorist(32, 39);
    yellow = kolorist(33, 39);
    blue = kolorist(34, 39);
    magenta = kolorist(35, 39);
    cyan = kolorist(36, 39);
    white = kolorist(97, 39);
    gray = kolorist(90, 39);
    lightGray = kolorist(37, 39);
    lightRed = kolorist(91, 39);
    lightGreen = kolorist(92, 39);
    lightYellow = kolorist(93, 39);
    lightBlue = kolorist(94, 39);
    lightMagenta = kolorist(95, 39);
    lightCyan = kolorist(96, 39);
    bgBlack = kolorist(40, 49);
    bgRed = kolorist(41, 49);
    bgGreen = kolorist(42, 49);
    bgYellow = kolorist(43, 49);
    bgBlue = kolorist(44, 49);
    bgMagenta = kolorist(45, 49);
    bgCyan = kolorist(46, 49);
    bgWhite = kolorist(107, 49);
    bgGray = kolorist(100, 49);
    bgLightRed = kolorist(101, 49);
    bgLightGreen = kolorist(102, 49);
    bgLightYellow = kolorist(103, 49);
    bgLightBlue = kolorist(104, 49);
    bgLightMagenta = kolorist(105, 49);
    bgLightCyan = kolorist(106, 49);
    bgLightGray = kolorist(47, 49);
    ansi256 = function(n) {
      return kolorist(
        "38;5;" + n,
        0,
        2
        /* ansi256 */
      );
    };
    ansi256Bg = function(n) {
      return kolorist(
        "48;5;" + n,
        0,
        2
        /* ansi256 */
      );
    };
    trueColor = function(r, g, b) {
      return options.supportLevel === 2 ? ansi256(rgbToAnsi256(r, g, b)) : kolorist(
        "38;2;" + r + ";" + g + ";" + b,
        0,
        3
        /* trueColor */
      );
    };
    trueColorBg = function(r, g, b) {
      return options.supportLevel === 2 ? ansi256Bg(rgbToAnsi256(r, g, b)) : kolorist(
        "48;2;" + r + ";" + g + ";" + b,
        0,
        3
        /* trueColor */
      );
    };
    OSC = "\x1B]";
    BEL = "\x07";
    SEP = ";";
  }
});

// browser-external:node:fs
var require_node_fs = __commonJS({
  "browser-external:node:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:fs" has been externalized for browser compatibility. Cannot access "node:fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:module
var require_node_module = __commonJS({
  "browser-external:node:module"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:module" has been externalized for browser compatibility. Cannot access "node:module.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:path
var require_node_path = __commonJS({
  "browser-external:node:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:path" has been externalized for browser compatibility. Cannot access "node:path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:process
var require_node_process = __commonJS({
  "browser-external:node:process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:process" has been externalized for browser compatibility. Cannot access "node:process.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:fs/promises
var require_promises = __commonJS({
  "browser-external:node:fs/promises"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:fs/promises" has been externalized for browser compatibility. Cannot access "node:fs/promises.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:url
var require_node_url = __commonJS({
  "browser-external:node:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:url" has been externalized for browser compatibility. Cannot access "node:url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:assert
var require_node_assert = __commonJS({
  "browser-external:node:assert"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:assert" has been externalized for browser compatibility. Cannot access "node:assert.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:v8
var require_node_v8 = __commonJS({
  "browser-external:node:v8"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:v8" has been externalized for browser compatibility. Cannot access "node:v8.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:util
var require_node_util = __commonJS({
  "browser-external:node:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:util" has been externalized for browser compatibility. Cannot access "node:util.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../node_modules/package-manager-detector/dist/constants.mjs
var AGENTS, LOCKS, INSTALL_METADATA;
var init_constants = __esm({
  "../node_modules/package-manager-detector/dist/constants.mjs"() {
    AGENTS = [
      "npm",
      "yarn",
      "yarn@berry",
      "pnpm",
      "pnpm@6",
      "bun",
      "deno"
    ];
    LOCKS = {
      "bun.lock": "bun",
      "bun.lockb": "bun",
      "deno.lock": "deno",
      "pnpm-lock.yaml": "pnpm",
      "pnpm-workspace.yaml": "pnpm",
      "yarn.lock": "yarn",
      "package-lock.json": "npm",
      "npm-shrinkwrap.json": "npm"
    };
    INSTALL_METADATA = {
      "node_modules/.deno/": "deno",
      "node_modules/.pnpm/": "pnpm",
      "node_modules/.yarn-state.yml": "yarn",
      // yarn v2+ (node-modules)
      "node_modules/.yarn_integrity": "yarn",
      // yarn v1
      "node_modules/.package-lock.json": "npm",
      ".pnp.cjs": "yarn",
      // yarn v3+ (pnp)
      ".pnp.js": "yarn",
      // yarn v2 (pnp)
      "bun.lock": "bun",
      "bun.lockb": "bun"
    };
  }
});

// ../node_modules/package-manager-detector/dist/detect.mjs
var detect_exports = {};
__export(detect_exports, {
  detect: () => detect,
  getUserAgent: () => getUserAgent
});
async function pathExists(path2, type) {
  try {
    const stat = await import_promises.default.stat(path2);
    return type === "file" ? stat.isFile() : stat.isDirectory();
  } catch {
    return false;
  }
}
function getUserAgent() {
  const userAgent = import_node_process.default.env.npm_config_user_agent;
  if (!userAgent) {
    return null;
  }
  const name = userAgent.split("/")[0];
  return AGENTS.includes(name) ? name : null;
}
function* lookup(cwd = import_node_process.default.cwd()) {
  let directory = import_node_path.default.resolve(cwd);
  const { root } = import_node_path.default.parse(directory);
  while (directory && directory !== root) {
    yield directory;
    directory = import_node_path.default.dirname(directory);
  }
}
async function parsePackageJson(filepath, onUnknown) {
  return !filepath || !pathExists(filepath, "file") ? null : await handlePackageManager(filepath, onUnknown);
}
async function detect(options2 = {}) {
  const {
    cwd,
    strategies = ["lockfile", "packageManager-field", "devEngines-field"],
    onUnknown
  } = options2;
  let stopDir;
  if (typeof options2.stopDir === "string") {
    const resolved = import_node_path.default.resolve(options2.stopDir);
    stopDir = (dir) => dir === resolved;
  } else {
    stopDir = options2.stopDir;
  }
  for (const directory of lookup(cwd)) {
    for (const strategy of strategies) {
      switch (strategy) {
        case "lockfile": {
          for (const lock of Object.keys(LOCKS)) {
            if (await pathExists(import_node_path.default.join(directory, lock), "file")) {
              const name = LOCKS[lock];
              const result = await parsePackageJson(import_node_path.default.join(directory, "package.json"), onUnknown);
              if (result)
                return result;
              else
                return { name, agent: name };
            }
          }
          break;
        }
        case "packageManager-field":
        case "devEngines-field": {
          const result = await parsePackageJson(import_node_path.default.join(directory, "package.json"), onUnknown);
          if (result)
            return result;
          break;
        }
        case "install-metadata": {
          for (const metadata of Object.keys(INSTALL_METADATA)) {
            const fileOrDir = metadata.endsWith("/") ? "dir" : "file";
            if (await pathExists(import_node_path.default.join(directory, metadata), fileOrDir)) {
              const name = INSTALL_METADATA[metadata];
              const agent = name === "yarn" ? isMetadataYarnClassic(metadata) ? "yarn" : "yarn@berry" : name;
              return { name, agent };
            }
          }
          break;
        }
      }
    }
    if (stopDir == null ? void 0 : stopDir(directory))
      break;
  }
  return null;
}
function getNameAndVer(pkg) {
  var _a, _b;
  const handelVer = (version) => {
    var _a2;
    return ((_a2 = version == null ? void 0 : version.match(/\d+(\.\d+){0,2}/)) == null ? void 0 : _a2[0]) ?? version;
  };
  if (typeof pkg.packageManager === "string") {
    const [name, ver] = pkg.packageManager.replace(/^\^/, "").split("@");
    return { name, ver: handelVer(ver) };
  }
  if (typeof ((_b = (_a = pkg.devEngines) == null ? void 0 : _a.packageManager) == null ? void 0 : _b.name) === "string") {
    return {
      name: pkg.devEngines.packageManager.name,
      ver: handelVer(pkg.devEngines.packageManager.version)
    };
  }
  return void 0;
}
async function handlePackageManager(filepath, onUnknown) {
  try {
    const pkg = JSON.parse(await import_promises.default.readFile(filepath, "utf8"));
    let agent;
    const nameAndVer = getNameAndVer(pkg);
    if (nameAndVer) {
      const name = nameAndVer.name;
      const ver = nameAndVer.ver;
      let version = ver;
      if (name === "yarn" && ver && Number.parseInt(ver) > 1) {
        agent = "yarn@berry";
        version = "berry";
        return { name, agent, version };
      } else if (name === "pnpm" && ver && Number.parseInt(ver) < 7) {
        agent = "pnpm@6";
        return { name, agent, version };
      } else if (AGENTS.includes(name)) {
        agent = name;
        return { name, agent, version };
      } else {
        return (onUnknown == null ? void 0 : onUnknown(pkg.packageManager)) ?? null;
      }
    }
  } catch {
  }
  return null;
}
function isMetadataYarnClassic(metadataPath) {
  return metadataPath.endsWith(".yarn_integrity");
}
var import_promises, import_node_path, import_node_process;
var init_detect = __esm({
  "../node_modules/package-manager-detector/dist/detect.mjs"() {
    import_promises = __toESM(require_promises(), 1);
    import_node_path = __toESM(require_node_path(), 1);
    import_node_process = __toESM(require_node_process(), 1);
    init_constants();
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../node_modules/process/browser.js
var require_browser2 = __commonJS({
  "../node_modules/process/browser.js"(exports, module) {
    var process3 = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process3.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process3.title = "browser";
    process3.browser = true;
    process3.env = {};
    process3.argv = [];
    process3.version = "";
    process3.versions = {};
    function noop() {
    }
    process3.on = noop;
    process3.addListener = noop;
    process3.once = noop;
    process3.off = noop;
    process3.removeListener = noop;
    process3.removeAllListeners = noop;
    process3.emit = noop;
    process3.prependListener = noop;
    process3.prependOnceListener = noop;
    process3.listeners = function(name) {
      return [];
    };
    process3.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process3.cwd = function() {
      return "/";
    };
    process3.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process3.umask = function() {
      return 0;
    };
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:readline
var require_readline = __commonJS({
  "browser-external:readline"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "readline" has been externalized for browser compatibility. Cannot access "readline.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../node_modules/tinyexec/dist/main.js
var main_exports = {};
__export(main_exports, {
  ExecProcess: () => R,
  NonZeroExitError: () => x,
  exec: () => be,
  x: () => ve
});
function jt(t) {
  for (let e in t) {
    if (!Object.prototype.hasOwnProperty.call(t, e) || !Lt.test(e))
      continue;
    let n = t[e];
    return n ? { key: e, value: n } : q;
  }
  return q;
}
function Ft(t, e) {
  let n = e.value.split(import_path2.delimiter), r = t, s;
  do
    n.push((0, import_path2.resolve)(r, "node_modules", ".bin")), s = r, r = (0, import_path2.dirname)(r);
  while (r !== s);
  return { key: e.key, value: n.join(import_path2.delimiter) };
}
function I(t, e) {
  let n = {
    ...process.env,
    ...e
  }, r = Ft(t, jt(n));
  return n[r.key] = r.value, n;
}
function we(t, e) {
  return {
    command: (0, import_path.normalize)(t),
    args: e ?? []
  };
}
function xe(t) {
  let e = new AbortController();
  for (let n of t) {
    if (n.aborted)
      return e.abort(), n;
    let r = () => {
      e.abort(n.reason);
    };
    n.addEventListener("abort", r, {
      signal: e.signal
    });
  }
  return e.signal;
}
var import_node_module, import_child_process, import_path, import_process, import_path2, import_stream, import_readline, require2, St, $, kt, Tt, At, Rt, h, l, $t, Nt, W, X, U, et, rt, ct, ut, lt, dt, ht, wt, bt, Ct, Lt, q, L, Pt, x, ge, Ee, R, ve, be;
var init_main = __esm({
  "../node_modules/tinyexec/dist/main.js"() {
    import_node_module = __toESM(require_node_module());
    import_child_process = __toESM(require_child_process());
    import_path = __toESM(require_path());
    import_process = __toESM(require_browser2());
    import_path2 = __toESM(require_path());
    import_stream = __toESM(require_stream());
    import_readline = __toESM(require_readline());
    require2 = (0, import_node_module.createRequire)(import.meta.url);
    St = Object.create;
    $ = Object.defineProperty;
    kt = Object.getOwnPropertyDescriptor;
    Tt = Object.getOwnPropertyNames;
    At = Object.getPrototypeOf;
    Rt = Object.prototype.hasOwnProperty;
    h = ((t) => typeof require2 < "u" ? require2 : typeof Proxy < "u" ? new Proxy(t, {
      get: (e, n) => (typeof require2 < "u" ? require2 : e)[n]
    }) : t)(function(t) {
      if (typeof require2 < "u")
        return require2.apply(this, arguments);
      throw Error('Dynamic require of "' + t + '" is not supported');
    });
    l = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
    $t = (t, e, n, r) => {
      if (e && typeof e == "object" || typeof e == "function")
        for (let s of Tt(e))
          !Rt.call(t, s) && s !== n && $(t, s, { get: () => e[s], enumerable: !(r = kt(e, s)) || r.enumerable });
      return t;
    };
    Nt = (t, e, n) => (n = t != null ? St(At(t)) : {}, $t(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      e || !t || !t.__esModule ? $(n, "default", { value: t, enumerable: true }) : n,
      t
    ));
    W = l((Se, H) => {
      "use strict";
      H.exports = z;
      z.sync = Wt;
      var j = h("fs");
      function Ht(t, e) {
        var n = e.pathExt !== void 0 ? e.pathExt : process.env.PATHEXT;
        if (!n || (n = n.split(";"), n.indexOf("") !== -1))
          return true;
        for (var r = 0; r < n.length; r++) {
          var s = n[r].toLowerCase();
          if (s && t.substr(-s.length).toLowerCase() === s)
            return true;
        }
        return false;
      }
      function F(t, e, n) {
        return !t.isSymbolicLink() && !t.isFile() ? false : Ht(e, n);
      }
      function z(t, e, n) {
        j.stat(t, function(r, s) {
          n(r, r ? false : F(s, t, e));
        });
      }
      function Wt(t, e) {
        return F(j.statSync(t), t, e);
      }
    });
    X = l((ke, B) => {
      "use strict";
      B.exports = K;
      K.sync = Dt;
      var D = h("fs");
      function K(t, e, n) {
        D.stat(t, function(r, s) {
          n(r, r ? false : M(s, e));
        });
      }
      function Dt(t, e) {
        return M(D.statSync(t), e);
      }
      function M(t, e) {
        return t.isFile() && Kt(t, e);
      }
      function Kt(t, e) {
        var n = t.mode, r = t.uid, s = t.gid, o = e.uid !== void 0 ? e.uid : process.getuid && process.getuid(), i = e.gid !== void 0 ? e.gid : process.getgid && process.getgid(), a = parseInt("100", 8), c = parseInt("010", 8), u = parseInt("001", 8), f = a | c, p = n & u || n & c && s === i || n & a && r === o || n & f && o === 0;
        return p;
      }
    });
    U = l((Ae, G) => {
      "use strict";
      var Te = h("fs"), v;
      process.platform === "win32" || global.TESTING_WINDOWS ? v = W() : v = X();
      G.exports = y;
      y.sync = Mt;
      function y(t, e, n) {
        if (typeof e == "function" && (n = e, e = {}), !n) {
          if (typeof Promise != "function")
            throw new TypeError("callback not provided");
          return new Promise(function(r, s) {
            y(t, e || {}, function(o, i) {
              o ? s(o) : r(i);
            });
          });
        }
        v(t, e || {}, function(r, s) {
          r && (r.code === "EACCES" || e && e.ignoreErrors) && (r = null, s = false), n(r, s);
        });
      }
      function Mt(t, e) {
        try {
          return v.sync(t, e || {});
        } catch (n) {
          if (e && e.ignoreErrors || n.code === "EACCES")
            return false;
          throw n;
        }
      }
    });
    et = l((Re, tt) => {
      "use strict";
      var g = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", Y = h("path"), Bt = g ? ";" : ":", V = U(), J = (t) => Object.assign(new Error(`not found: ${t}`), { code: "ENOENT" }), Q = (t, e) => {
        let n = e.colon || Bt, r = t.match(/\//) || g && t.match(/\\/) ? [""] : [
          // windows always checks the cwd first
          ...g ? [process.cwd()] : [],
          ...(e.path || process.env.PATH || /* istanbul ignore next: very unusual */
          "").split(n)
        ], s = g ? e.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", o = g ? s.split(n) : [""];
        return g && t.indexOf(".") !== -1 && o[0] !== "" && o.unshift(""), {
          pathEnv: r,
          pathExt: o,
          pathExtExe: s
        };
      }, Z = (t, e, n) => {
        typeof e == "function" && (n = e, e = {}), e || (e = {});
        let { pathEnv: r, pathExt: s, pathExtExe: o } = Q(t, e), i = [], a = (u) => new Promise((f, p) => {
          if (u === r.length)
            return e.all && i.length ? f(i) : p(J(t));
          let d = r[u], w = /^".*"$/.test(d) ? d.slice(1, -1) : d, m = Y.join(w, t), b = !w && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + m : m;
          f(c(b, u, 0));
        }), c = (u, f, p) => new Promise((d, w) => {
          if (p === s.length)
            return d(a(f + 1));
          let m = s[p];
          V(u + m, { pathExt: o }, (b, Ot) => {
            if (!b && Ot)
              if (e.all)
                i.push(u + m);
              else
                return d(u + m);
            return d(c(u, f, p + 1));
          });
        });
        return n ? a(0).then((u) => n(null, u), n) : a(0);
      }, Xt = (t, e) => {
        e = e || {};
        let { pathEnv: n, pathExt: r, pathExtExe: s } = Q(t, e), o = [];
        for (let i = 0; i < n.length; i++) {
          let a = n[i], c = /^".*"$/.test(a) ? a.slice(1, -1) : a, u = Y.join(c, t), f = !c && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + u : u;
          for (let p = 0; p < r.length; p++) {
            let d = f + r[p];
            try {
              if (V.sync(d, { pathExt: s }))
                if (e.all)
                  o.push(d);
                else
                  return d;
            } catch {
            }
          }
        }
        if (e.all && o.length)
          return o;
        if (e.nothrow)
          return null;
        throw J(t);
      };
      tt.exports = Z;
      Z.sync = Xt;
    });
    rt = l(($e, _) => {
      "use strict";
      var nt = (t = {}) => {
        let e = t.env || process.env;
        return (t.platform || process.platform) !== "win32" ? "PATH" : Object.keys(e).reverse().find((r) => r.toUpperCase() === "PATH") || "Path";
      };
      _.exports = nt;
      _.exports.default = nt;
    });
    ct = l((Ne, it) => {
      "use strict";
      var st = h("path"), Gt = et(), Ut = rt();
      function ot(t, e) {
        let n = t.options.env || process.env, r = process.cwd(), s = t.options.cwd != null, o = s && process.chdir !== void 0 && !process.chdir.disabled;
        if (o)
          try {
            process.chdir(t.options.cwd);
          } catch {
          }
        let i;
        try {
          i = Gt.sync(t.command, {
            path: n[Ut({ env: n })],
            pathExt: e ? st.delimiter : void 0
          });
        } catch {
        } finally {
          o && process.chdir(r);
        }
        return i && (i = st.resolve(s ? t.options.cwd : "", i)), i;
      }
      function Yt(t) {
        return ot(t) || ot(t, true);
      }
      it.exports = Yt;
    });
    ut = l((qe, P) => {
      "use strict";
      var C = /([()\][%!^"`<>&|;, *?])/g;
      function Vt(t) {
        return t = t.replace(C, "^$1"), t;
      }
      function Jt(t, e) {
        return t = `${t}`, t = t.replace(/(\\*)"/g, '$1$1\\"'), t = t.replace(/(\\*)$/, "$1$1"), t = `"${t}"`, t = t.replace(C, "^$1"), e && (t = t.replace(C, "^$1")), t;
      }
      P.exports.command = Vt;
      P.exports.argument = Jt;
    });
    lt = l((Ie, at) => {
      "use strict";
      at.exports = /^#!(.*)/;
    });
    dt = l((Le, pt) => {
      "use strict";
      var Qt = lt();
      pt.exports = (t = "") => {
        let e = t.match(Qt);
        if (!e)
          return null;
        let [n, r] = e[0].replace(/#! ?/, "").split(" "), s = n.split("/").pop();
        return s === "env" ? r : r ? `${s} ${r}` : s;
      };
    });
    ht = l((je, ft) => {
      "use strict";
      var O = h("fs"), Zt = dt();
      function te(t) {
        let n = Buffer.alloc(150), r;
        try {
          r = O.openSync(t, "r"), O.readSync(r, n, 0, 150, 0), O.closeSync(r);
        } catch {
        }
        return Zt(n.toString());
      }
      ft.exports = te;
    });
    wt = l((Fe, Et) => {
      "use strict";
      var ee = h("path"), mt = ct(), gt = ut(), ne = ht(), re = process.platform === "win32", se = /\.(?:com|exe)$/i, oe = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
      function ie(t) {
        t.file = mt(t);
        let e = t.file && ne(t.file);
        return e ? (t.args.unshift(t.file), t.command = e, mt(t)) : t.file;
      }
      function ce(t) {
        if (!re)
          return t;
        let e = ie(t), n = !se.test(e);
        if (t.options.forceShell || n) {
          let r = oe.test(e);
          t.command = ee.normalize(t.command), t.command = gt.command(t.command), t.args = t.args.map((o) => gt.argument(o, r));
          let s = [t.command].concat(t.args).join(" ");
          t.args = ["/d", "/s", "/c", `"${s}"`], t.command = process.env.comspec || "cmd.exe", t.options.windowsVerbatimArguments = true;
        }
        return t;
      }
      function ue(t, e, n) {
        e && !Array.isArray(e) && (n = e, e = null), e = e ? e.slice(0) : [], n = Object.assign({}, n);
        let r = {
          command: t,
          args: e,
          options: n,
          file: void 0,
          original: {
            command: t,
            args: e
          }
        };
        return n.shell ? r : ce(r);
      }
      Et.exports = ue;
    });
    bt = l((ze, vt) => {
      "use strict";
      var S = process.platform === "win32";
      function k(t, e) {
        return Object.assign(new Error(`${e} ${t.command} ENOENT`), {
          code: "ENOENT",
          errno: "ENOENT",
          syscall: `${e} ${t.command}`,
          path: t.command,
          spawnargs: t.args
        });
      }
      function ae(t, e) {
        if (!S)
          return;
        let n = t.emit;
        t.emit = function(r, s) {
          if (r === "exit") {
            let o = xt(s, e, "spawn");
            if (o)
              return n.call(t, "error", o);
          }
          return n.apply(t, arguments);
        };
      }
      function xt(t, e) {
        return S && t === 1 && !e.file ? k(e.original, "spawn") : null;
      }
      function le(t, e) {
        return S && t === 1 && !e.file ? k(e.original, "spawnSync") : null;
      }
      vt.exports = {
        hookChildProcess: ae,
        verifyENOENT: xt,
        verifyENOENTSync: le,
        notFoundError: k
      };
    });
    Ct = l((He, E) => {
      "use strict";
      var yt = h("child_process"), T = wt(), A = bt();
      function _t(t, e, n) {
        let r = T(t, e, n), s = yt.spawn(r.command, r.args, r.options);
        return A.hookChildProcess(s, r), s;
      }
      function pe(t, e, n) {
        let r = T(t, e, n), s = yt.spawnSync(r.command, r.args, r.options);
        return s.error = s.error || A.verifyENOENTSync(s.status, r), s;
      }
      E.exports = _t;
      E.exports.spawn = _t;
      E.exports.sync = pe;
      E.exports._parse = T;
      E.exports._enoent = A;
    });
    Lt = /^path$/i;
    q = { key: "PATH", value: "" };
    L = (t) => {
      let e = t.length, n = new import_stream.PassThrough(), r = () => {
        --e === 0 && n.emit("end");
      };
      for (let s of t)
        s.pipe(n, { end: false }), s.on("end", r);
      return n;
    };
    Pt = Nt(Ct(), 1);
    x = class extends Error {
      constructor(e, n) {
        super(`Process exited with non-zero status (${e.exitCode})`);
        __publicField(this, "result");
        __publicField(this, "output");
        this.result = e, this.output = n;
      }
      get exitCode() {
        if (this.result.exitCode !== null)
          return this.result.exitCode;
      }
    };
    ge = {
      timeout: void 0,
      persist: false
    };
    Ee = {
      windowsHide: true
    };
    R = class {
      constructor(e, n, r) {
        __publicField(this, "_process");
        __publicField(this, "_aborted", false);
        __publicField(this, "_options");
        __publicField(this, "_command");
        __publicField(this, "_args");
        __publicField(this, "_resolveClose");
        __publicField(this, "_processClosed");
        __publicField(this, "_thrownError");
        __publicField(this, "_streamOut");
        __publicField(this, "_streamErr");
        __publicField(this, "_onError", (e) => {
          if (e.name === "AbortError" && (!(e.cause instanceof Error) || e.cause.name !== "TimeoutError")) {
            this._aborted = true;
            return;
          }
          this._thrownError = e;
        });
        __publicField(this, "_onClose", () => {
          this._resolveClose && this._resolveClose();
        });
        this._options = {
          ...ge,
          ...r
        }, this._command = e, this._args = n ?? [], this._processClosed = new Promise((s) => {
          this._resolveClose = s;
        });
      }
      get process() {
        return this._process;
      }
      get pid() {
        var _a;
        return (_a = this._process) == null ? void 0 : _a.pid;
      }
      get exitCode() {
        if (this._process && this._process.exitCode !== null)
          return this._process.exitCode;
      }
      kill(e) {
        var _a;
        return ((_a = this._process) == null ? void 0 : _a.kill(e)) === true;
      }
      get aborted() {
        return this._aborted;
      }
      get killed() {
        var _a;
        return ((_a = this._process) == null ? void 0 : _a.killed) === true;
      }
      pipe(e, n, r) {
        return be(e, n, {
          ...r,
          stdin: this
        });
      }
      async *[Symbol.asyncIterator]() {
        var _a;
        let e = this._process;
        if (!e)
          return;
        let n = [];
        this._streamErr && n.push(this._streamErr), this._streamOut && n.push(this._streamOut);
        let r = L(n), s = import_readline.default.createInterface({
          input: r
        });
        for await (let o of s)
          yield o.toString();
        if (await this._processClosed, e.removeAllListeners(), this._thrownError)
          throw this._thrownError;
        if (((_a = this._options) == null ? void 0 : _a.throwOnError) && this.exitCode !== 0 && this.exitCode !== void 0)
          throw new x(this);
      }
      async _waitForOutput() {
        var _a;
        let e = this._process;
        if (!e)
          throw new Error("No process was started");
        let n = "", r = "";
        if (this._streamOut)
          for await (let o of this._streamOut)
            r += o.toString();
        if (this._streamErr)
          for await (let o of this._streamErr)
            n += o.toString();
        if (await this._processClosed, ((_a = this._options) == null ? void 0 : _a.stdin) && await this._options.stdin, e.removeAllListeners(), this._thrownError)
          throw this._thrownError;
        let s = {
          stderr: n,
          stdout: r,
          exitCode: this.exitCode
        };
        if (this._options.throwOnError && this.exitCode !== 0 && this.exitCode !== void 0)
          throw new x(this, s);
        return s;
      }
      then(e, n) {
        return this._waitForOutput().then(e, n);
      }
      spawn() {
        let e = (0, import_process.cwd)(), n = this._options, r = {
          ...Ee,
          ...n.nodeOptions
        }, s = [];
        this._resetState(), n.timeout !== void 0 && s.push(AbortSignal.timeout(n.timeout)), n.signal !== void 0 && s.push(n.signal), n.persist === true && (r.detached = true), s.length > 0 && (r.signal = xe(s)), r.env = I(e, r.env);
        let { command: o, args: i } = we(this._command, this._args), a = (0, Pt._parse)(o, i, r), c = (0, import_child_process.spawn)(
          a.command,
          a.args,
          a.options
        );
        if (c.stderr && (this._streamErr = c.stderr), c.stdout && (this._streamOut = c.stdout), this._process = c, c.once("error", this._onError), c.once("close", this._onClose), n.stdin !== void 0 && c.stdin && n.stdin.process) {
          let { stdout: u } = n.stdin.process;
          u && u.pipe(c.stdin);
        }
      }
      _resetState() {
        this._aborted = false, this._processClosed = new Promise((e) => {
          this._resolveClose = e;
        }), this._thrownError = void 0;
      }
    };
    ve = (t, e, n) => {
      let r = new R(t, e, n);
      return r.spawn(), r;
    };
    be = ve;
  }
});

export {
  require_browser,
  require_fs,
  require_node_fs,
  require_node_module,
  require_node_path,
  require_node_process,
  require_promises,
  require_node_url,
  require_node_assert,
  require_node_v8,
  require_node_util,
  detect,
  detect_exports,
  init_detect,
  require_path,
  require_browser2,
  ve,
  main_exports,
  init_main,
  yellow,
  cyan,
  module_exports,
  init_module
};
//# sourceMappingURL=chunk-R5PGMNMD.js.map
